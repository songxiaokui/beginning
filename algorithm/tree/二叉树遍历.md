### 二叉树的遍历
* 定义与实现
    ```C++
    // tree.h
    namespace Tree {
        struct Tree {
            int val;
            Tree *left;
            Tree *right;
    
            Tree(int val);
            ~Tree();
        };
    
        void testTree(void);
    }
    
    // tree.cpp
    namespace Tree {
        Tree::Tree(int val) : val(val), left(nullptr), right(nullptr) {}
    
        // 析构
        Tree::~Tree() {
            if (this->left) {
                delete this->left;
                this->left = nullptr;
    
            }
            if (this->right) {
                delete this->right;
                this->right = nullptr;
            }
        }
    }
    ```
* BFS(广度优先)
  ```C++
    // BFS 广度优先遍历
    void BFS(Tree *&root) {
        vector<Tree *> queue;
        queue.push_back(root);
        // 初始化动态数组
        // 将根节点放在数组中
        while (!queue.empty()) {
            // 弹出当前元素
            Tree *current_node = queue.front();
            // 删除当前元素(头部)
            queue.erase(queue.begin());

            // 输出数据
            cout << current_node->val << "->";
            // 如果左子节点不为空 加入数组
            if (current_node->left != nullptr) {
                queue.push_back(current_node->left);
            }
            // 如果右子节点不为空 加入数组
            if (current_node->right != nullptr) {
                queue.push_back(current_node->right);
            }
        }

        cout << "NULL" << endl;
        queue.clear();
    }
  ```
* DFS(深度优先)
* 先序遍历
* 中序遍历
* 后序遍历