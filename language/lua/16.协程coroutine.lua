---
--- Generated by Luanalysis
--- Created by austsxk.
--- DateTime: 2024/2/2 09:50
---

--[[
注意一点即可:
yield: 返回值是返回给外部函数
resume: 参数是传入给yield上次返回的变量
通过yield与resume的配合，可以实现内部处理数据外传，外部修改内部的输入。通过运行时控制输入

基本使用:
使用模块coroutine 模块实现
1. 创建一个coroutine coroutine.create(处理的函数)
2. 调用 coroutine.resume(协程对象, 函数参数1, 函数参数2,...)
3. 挂起调用与返回中间值 coroutine.yield(返回给外部值1, 返回给外部值2, ...)
4. 查询协程状态 coroutine.status()
5. 包装一个coroutine 返回的对象与crete相同 coroutine.warp()
--]]

-- 使用coroutine实现生产者与消费者模式
--[[
场景描述:
一个生产
一个消费
--]]

function producer(max)
    local i = 0
    repeat
        -- 生产数据
        i = i + 1
        send(true, i)
    until
    i == max
    send(false, -1)
end

function send(status, i)
    coroutine.yield(status, i)
end

function consumer(coroutine_obj, max)
    repeat
        local status, data = obtain(coroutine_obj, max)
        print("接受的数据: " .. data)
    until
    status == false
end

function obtain(coroutine_obj, max)
    local _, status, value = coroutine.resume(coroutine_obj, max) -- 第一个时协程的状态 不要
    return status, value
end

local co = coroutine.create(producer)
consumer(co, 20)


